# MAC0338

[[notacao-assintotica]]

Como resolver recorrências?
- Método da substituição
- Método da árvore recursiva
- 

# Aula 7

[[counting sort]]
  - https://youtu.be/pEJiGC-ObQE?feature=shared
- Radix sort
  - Necessita de um [[algoritmo estável]] para ordenar cada iteração
- Bucket sort
  - DUVIDA: Por que $Y_i \leq X_i^2$? no slide 49?
    - RESPOSTA: Porque consideramos todos os pares de valores do vetor. É um limitante superior (grosseiro) para $Y_i$. Poderíamos usar o limitante $Y_i \leq \binom{X_i}{2} \leq X_i^2$, já que cada par de valores do vetor é comparado no máximo 1 vez no insertion sort.

# Aula 8

Multiplicação de inteiros gigantescos

- Gauss
- Karatsuba

# Aula 9

- Seleção em tempo linear
A ideia inicial é achar um bom pivô para o PARTICIONA do quicksort.


# Aula complementar (31/10)

Vamos apresentar alguns problemas famosos de programação dinâmica.

## PD das moedas (Coin Change)

Dado um conjunto de moedas $C = \{c_1, c_2, \dots, c_n\}$ e um valor $v$, qual é o menor número de moedas necessárias para formar $v$?
Seja $f(x)$ o menor número de moedas necessárias para formar $x$. Então,

$f(x) = \min\set{1 + f(x-C[i]) : C[i] \leq x}$.

A base da recursão é $f(0) = 0$.

```
// Seja n o numero de moedas no vetor C[]
// Seja f[] o vetor das solucoes para 1, 2, ..., x moedas
// Vamos preenchendo o vetor f[] por bottom-up
f(v):
  if(v == 0):
    return 0
  for(i=1, i<=v, i++):
    for(j=1, j<=n, j++):
      if(C[j] <= i):
        f[i] = min(f(i), f(i-C[j]) + 1)
  return f(v)
```

A complexidade é de $\Theta(nv)$.

## Longest Increasing Subsequence (LIS)

Dado um vetor $A[1..n]$, qual é o tamanho da maior subsequência crescente?
obs.: subsequência não é necessariamente subvetor, sendo que a subsequência pode considerar elementos não adjacentes.

Queremos uma subsequência crescente $X[1..k]$ tal que $\forall i \in [k], A[x_i] > A[x_j] \text{ tal que } j<i$

A função de recorrência é $LIS(i) = 1 + \max{LIS(j)} \text{ se } j<i \text{ e } A(j)<A(i) \text{ OU 1 c.c}$

```
// Seja LIS[] o vetor das solucoes para 1, 2, ..., n elementos
PDLIS(A,n):
  for(i=1, i<=n, i++):
    LIS[i] = 1
  for(i=2, i<=n, i++):
    for(j=1, j<i-1, j++):
      if(A[j] < A[i] && LIS[i] < LIS[j] + 1):
        LIS[i] = LIS[j] + 1
  return max(LIS)
```

## String distance

Dadas duas strings $A$ e $B$, qual é a menor quantidade de operações necessárias para transformar $A$ em $B$?
As operações são:
- Inserir um caractere
- Remover um caractere
- Substituir um caractere

O subproblema é $d(i,j)$, que é a distância entre os prefixos $A[1..i]$ e $B[1..j]$.

# Aula 11 - [[algoritmo guloso]]
# Aula 12 - [[códigos de Huffman]]

